/// @title LIQFlashV2 - Ultra-optimized Flash Mint in Huff
/// @notice No storage writes - tokens are virtual during callback
/// @dev Simplified stack management for correctness

// ============ CONSTANTS ============

#define constant CALLBACK_SUCCESS = 0x439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd9

// Function selectors  
#define constant FLASH_LOAN_SIG = 0x5cffe9de
#define constant ON_FLASH_LOAN_SIG = 0x23e30c8b
#define constant MAX_FLASH_LOAN_SIG = 0x613255ab
#define constant FLASH_FEE_SIG = 0xd9d98ce4

// ============ MAIN ============

#define macro MAIN() = takes(0) returns(0) {
    0x00 calldataload 0xe0 shr
    
    dup1 [FLASH_LOAN_SIG] eq flash_loan jumpi
    dup1 [MAX_FLASH_LOAN_SIG] eq max_flash_loan jumpi
    dup1 [FLASH_FEE_SIG] eq flash_fee jumpi
    
    0x00 0x00 revert

    flash_loan:
        pop FLASH_LOAN()
    
    max_flash_loan:
        pop MAX_FLASH_LOAN()
    
    flash_fee:
        pop FLASH_FEE()
}

// ============ maxFlashLoan ============

#define macro MAX_FLASH_LOAN() = takes(0) returns(0) {
    0x04 calldataload address eq
    iszero ret_zero jumpi
    
    0x00 not 0x00 mstore
    0x20 0x00 return
    
    ret_zero:
        0x00 0x00 mstore
        0x20 0x00 return
}

// ============ flashFee ============

#define macro FLASH_FEE() = takes(0) returns(0) {
    0x04 calldataload address eq
    iszero fee_bad jumpi
    
    0x00 0x00 mstore
    0x20 0x00 return
    
    fee_bad:
        0x00 0x00 revert
}

// ============ flashLoan - THE CORE OPTIMIZATION ============
// Stack management done carefully to avoid issues

#define macro FLASH_LOAN() = takes(0) returns(0) {
    // Validate token == address(this)
    0x24 calldataload           // [token]
    address eq                  // [token==this]
    iszero bad_token jumpi
    
    // === Build calldata in memory starting at 0x80 ===
    
    // Selector: onFlashLoan (left-aligned)
    0x23e30c8b00000000000000000000000000000000000000000000000000000000
    0x80 mstore                 // []
    
    // initiator = msg.sender at 0x84
    caller 0x84 mstore          // []
    
    // token = address(this) at 0xa4
    address 0xa4 mstore         // []
    
    // amount at 0xc4
    0x44 calldataload           // [amount]
    0xc4 mstore                 // []
    
    // fee = 0 at 0xe4
    0x00 0xe4 mstore            // []
    
    // data offset = 0xa0 at 0x104
    0xa0 0x104 mstore           // []
    
    // Get data length from calldata
    // bytes calldata is ABI-encoded as offset then length then data
    0x64 calldataload           // [offset_to_data]
    0x04 add                    // [ptr_to_len]
    dup1 calldataload           // [data_len, ptr_to_len]
    
    // Store data length at 0x124
    dup1 0x124 mstore           // [data_len, ptr_to_len]
    
    // Copy data to 0x144
    swap1                       // [ptr_to_len, data_len]
    0x20 add                    // [data_start, data_len]
    0x144                       // [dest, data_start, data_len]
    calldatacopy                // []  calldatacopy(dest, src, len)
    
    // === Make the CALL ===
    // call_size = 4 + 160 + data_len = 0xc4 + data_len
    0x64 calldataload 0x04 add calldataload   // [data_len]
    0xc4 add                    // [call_size]
    
    // CALL(gas, addr, value, argsOffset, argsSize, retOffset, retSize)
    // Build stack from bottom up for call opcode
    // call expects: gas addr value argOff argSize retOff retSize (top to bottom when consumed)
    
    0x20                        // [retSize, call_size]
    0x00                        // [retOff, retSize, call_size]
    dup3                        // [argSize, retOff, retSize, call_size]
    0x80                        // [argOff, argSize, retOff, retSize, call_size]
    0x00                        // [value, argOff, argSize, retOff, retSize, call_size]
    0x04 calldataload           // [receiver, value, argOff, argSize, retOff, retSize, call_size]
    gas                         // [gas, receiver, value, argOff, argSize, retOff, retSize, call_size]
    call                        // [success, call_size]
    
    // Check call success
    iszero call_fail jumpi
    pop                         // [] - discard call_size
    
    // Verify callback returned CALLBACK_SUCCESS
    0x00 mload                  // [ret_val]
    [CALLBACK_SUCCESS] eq       // [valid]
    iszero cb_fail jumpi
    
    // Return true
    0x01 0x00 mstore
    0x20 0x00 return
    
    bad_token:
        0x00 0x00 revert
    call_fail:
        0x00 0x00 revert
    cb_fail:
        0x00 0x00 revert
}
