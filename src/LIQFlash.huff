/// @title LIQFlash - Ultra-optimized Flash Mint in Huff
/// @notice No storage writes - tokens are virtual during callback
/// @dev Target: Sub-4000 gas for warm flash mint

// ============ CONSTANTS ============

// CALLBACK_SUCCESS = keccak256("ERC3156FlashBorrower.onFlashLoan")
#define constant CALLBACK_SUCCESS = 0x439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd9

// Function selectors
#define constant FLASH_LOAN_SIG = 0x5cffe9de  // flashLoan(address,address,uint256,bytes)
#define constant ON_FLASH_LOAN_SIG = 0x23e30c8b  // onFlashLoan(address,address,uint256,uint256,bytes)
#define constant MAX_FLASH_LOAN_SIG = 0x613255ab  // maxFlashLoan(address)
#define constant FLASH_FEE_SIG = 0xd9d98ce4  // flashFee(address,uint256)

// ============ MAIN DISPATCHER ============

#define macro MAIN() = takes(0) returns(0) {
    // Get function selector (first 4 bytes)
    0x00 calldataload 0xe0 shr          // [selector]
    
    // Dispatch to appropriate function
    dup1 [FLASH_LOAN_SIG] eq flash_loan jumpi
    dup1 [MAX_FLASH_LOAN_SIG] eq max_flash_loan jumpi
    dup1 [FLASH_FEE_SIG] eq flash_fee jumpi
    
    // Unknown selector - revert
    0x00 0x00 revert

    flash_loan:
        FLASH_LOAN()
    
    max_flash_loan:
        MAX_FLASH_LOAN()
    
    flash_fee:
        FLASH_FEE()
}

// ============ maxFlashLoan(address token) ============
// Returns type(uint256).max if token == address(this), else 0

#define macro MAX_FLASH_LOAN() = takes(0) returns(0) {
    // Load token address from calldata
    0x04 calldataload           // [token]
    address                     // [this, token]
    eq                          // [token == this]
    
    // If equal, return MAX_UINT256, else 0
    iszero                      // [token != this]
    return_zero jumpi
    
    // Return type(uint256).max
    0x00 not                    // [0xfff...fff]
    0x00 mstore
    0x20 0x00 return
    
    return_zero:
        0x00 0x00 mstore
        0x20 0x00 return
}

// ============ flashFee(address token, uint256 amount) ============
// Returns 0 (free flash mints) if token == address(this), else reverts

#define macro FLASH_FEE() = takes(0) returns(0) {
    // Load token address from calldata
    0x04 calldataload           // [token]
    address                     // [this, token]
    eq                          // [token == this]
    iszero                      // [token != this]
    
    // Revert if wrong token
    fee_revert jumpi
    
    // Return 0 (free flash loans)
    0x00 0x00 mstore
    0x20 0x00 return
    
    fee_revert:
        0x00 0x00 revert
}

// ============ flashLoan(address receiver, address token, uint256 amount, bytes data) ============
// ZERO storage writes - the core optimization

#define macro FLASH_LOAN() = takes(0) returns(0) {
    // ===== STEP 1: Validate token == address(this) =====
    0x24 calldataload           // [token]
    address                     // [this, token]
    eq                          // [token == this]
    iszero                      // [token != this]
    token_revert jumpi
    
    // ===== STEP 2: Build onFlashLoan calldata =====
    // Signature: onFlashLoan(address initiator, address token, uint256 amount, uint256 fee, bytes data)
    // Memory layout at 0x80:
    //   0x80: selector (4 bytes) + padding
    //   0x84: initiator (msg.sender)
    //   0xa4: token (this)
    //   0xc4: amount
    //   0xe4: fee (0)
    //   0x104: data offset (0xa0 = 160, relative to 0x84)
    //   0x124: data length
    //   0x144: data bytes
    
    // Store selector at 0x80 (left-aligned)
    [ON_FLASH_LOAN_SIG]         // [0x23e30c8b]
    0xe0 shl                    // [0x23e30c8b00...00]
    0x80 mstore                 // []
    
    // Store initiator = caller() at 0x84
    caller                      // [msg.sender]
    0x84 mstore                 // []
    
    // Store token = address(this) at 0xa4
    address                     // [this]
    0xa4 mstore                 // []
    
    // Store amount at 0xc4 (from calldata offset 0x44)
    0x44 calldataload           // [amount]
    0xc4 mstore                 // []
    
    // Store fee = 0 at 0xe4
    0x00                        // [0]
    0xe4 mstore                 // []
    
    // Store data offset at 0x104 (0xa0 = 160 bytes from 0x84)
    0xa0                        // [0xa0]
    0x104 mstore                // []
    
    // Get data length and offset from calldata
    // bytes data is at calldata offset 0x64 (100 dec)
    // This is an offset pointer, need to read actual offset then length
    0x64 calldataload           // [data_offset]
    0x04 add                    // [data_ptr = 4 + offset]
    dup1                        // [data_ptr, data_ptr]
    calldataload                // [data_len, data_ptr]
    
    // Store data length at 0x124
    dup1                        // [data_len, data_len, data_ptr]
    0x124 mstore                // [data_len, data_ptr]
    
    // Copy data bytes to 0x144
    // calldatacopy(destOffset, offset, size)
    swap1                       // [data_ptr, data_len]
    0x20 add                    // [data_start, data_len]
    swap1                       // [data_len, data_start]
    0x144                       // [0x144, data_len, data_start]
    swap2                       // [data_start, data_len, 0x144]
    swap1                       // [data_len, data_start, 0x144]
    swap2                       // [0x144, data_start, data_len]
    calldatacopy                // []  -- calldatacopy(0x144, data_start, data_len)
    
    // ===== STEP 3: Calculate call size and make CALL =====
    // Size = 4 (selector) + 5*32 (params) + data_len = 0xc4 + data_len
    0x64 calldataload           // [data_offset]
    0x04 add                    // [data_ptr]
    calldataload                // [data_len]
    0xc4 add                    // [call_size]
    
    // Load receiver from calldata
    0x04 calldataload           // [receiver, call_size]
    
    // CALL(gas, addr, value, argsOffset, argsSize, retOffset, retSize)
    // Stack order for CALL: gas, addr, value, argsOffset, argsSize, retOffset, retSize
    0x20                        // [retSize=32, receiver, call_size]
    0x00                        // [retOffset=0, retSize, receiver, call_size]
    dup4                        // [call_size, retOffset, retSize, receiver, call_size]
    0x80                        // [argsOffset=0x80, call_size, retOffset, retSize, receiver, call_size]
    swap1                       // [call_size, argsOffset, retOffset, retSize, receiver, call_size]
    swap4                       // [receiver, argsOffset, retOffset, retSize, call_size, call_size]
    swap3                       // [retSize, argsOffset, retOffset, receiver, call_size, call_size]
    swap2                       // [retOffset, argsOffset, retSize, receiver, call_size, call_size]
    swap1                       // [argsOffset, retOffset, retSize, receiver, call_size, call_size]
    
    // Now need: gas, receiver, 0, argsOffset, argsSize, retOffset, retSize
    // Current: [argsOffset, retOffset, retSize, receiver, call_size, call_size]
    
    // Let's rebuild the stack more carefully
    pop pop pop pop pop         // []
    
    // Reload everything cleanly
    0x04 calldataload           // [receiver]
    0x64 calldataload           // [data_offset, receiver]
    0x04 add                    // [data_ptr, receiver]
    calldataload                // [data_len, receiver]
    0xc4 add                    // [call_size, receiver]
    
    // CALL args: gas, addr, value, argsOffset, argsSize, retOffset, retSize
    0x20                        // [32, call_size, receiver]
    0x00                        // [0, 32, call_size, receiver]
    swap2                       // [call_size, 32, 0, receiver]
    0x80                        // [0x80, call_size, 32, 0, receiver]
    swap1                       // [call_size, 0x80, 32, 0, receiver]
    swap4                       // [receiver, 0x80, 32, 0, call_size]
    0x00                        // [0, receiver, 0x80, 32, 0, call_size]
    swap1                       // [receiver, 0, 0x80, 32, 0, call_size]
    gas                         // [gas, receiver, 0, 0x80, 32, 0, call_size]
    
    // Reorder: need gas, addr, value, argsOffset, argsSize, retOffset, retSize
    // Have: [gas, receiver, 0, 0x80, 32, 0, call_size]
    // Actually need: [retSize, retOffset, argsSize, argsOffset, value, addr, gas]
    // (stack top is first arg popped, CALL pops in order: gas, addr, value, argsOffset, argsSize, retOffset, retSize)
    
    // Rebuild correctly
    pop pop pop pop pop pop pop // []
    
    // Final approach - minimal stack manipulation
    0x64 calldataload 0x04 add calldataload  // [data_len]
    0xc4 add                    // [call_size]
    
    0x20                        // [retSize, call_size]
    0x00                        // [retOffset, retSize, call_size]
    dup3                        // [argsSize, retOffset, retSize, call_size]
    0x80                        // [argsOffset, argsSize, retOffset, retSize, call_size]
    0x00                        // [value, argsOffset, argsSize, retOffset, retSize, call_size]
    0x04 calldataload           // [receiver, value, argsOffset, argsSize, retOffset, retSize, call_size]
    gas                         // [gas, receiver, value, argsOffset, argsSize, retOffset, retSize, call_size]
    call                        // [success, call_size]
    swap1 pop                   // [success]
    
    // Check success
    iszero call_failed jumpi
    
    // ===== STEP 4: Verify callback return value =====
    // Return value is at memory 0x00 (32 bytes)
    0x00 mload                  // [return_value]
    [CALLBACK_SUCCESS]          // [expected, return_value]
    eq                          // [match]
    iszero callback_failed jumpi
    
    // ===== STEP 5: Return true =====
    0x01                        // [1]
    0x00 mstore                 // []
    0x20 0x00 return
    
    token_revert:
        0x00 0x00 revert
    
    call_failed:
        0x00 0x00 revert
    
    callback_failed:
        0x00 0x00 revert
}
